services:
  redis:                                   # # Dịch vụ Redis để cache/đếm/bảo vệ
    image: redis:latest               # # Image Redis mới nhất
    command: ["redis-server", "--appendonly", "yes"]  # Bật AOF để dữ liệu cache sống qua restart
    ports:
      - "6379:6379"                        # # (Dev) expose ra host; Prod có thể bỏ để chỉ nội bộ network
    environment:
      - TZ=Asia/Ho_Chi_Minh                # # Múi giờ
    volumes:
      - ./redis-data:/data                 # # Lưu trữ dữ liệu redis ra host để có thể xem dữ liệu lưu trữ
    restart: unless-stopped                # # Tự khởi động lại nếu dừng bất thường
  docker_api:
    # Cài đặt và khởi động: docker-compose up --build -d
    # Dừng lại image trước khi chạy lại: docker compose down
    build:
      context: .
    image: fastapi-app:0.0.1
    container_name: fastapi-app
    # Nạp tệp biến môi trường vào docker
    env_file:
      - .env

    # === Biến môi trường cho app ===
    environment:

      # === SQL Server trên host ===
      DB_HOST: "host.docker.internal"   # Win/mac: OK; Linux cần extra_hosts bên dưới
      DB_USER: ${DB_USER}   # Lấy trực tiếp từ tệp .env mà ko cần nạp
      DB_PASSWORD: ${DB_PASSWORD}
      DB_NAME: ${DB_NAME}

      # === Thư mục gốc lưu file upload TRONG CONTAINER ===
      UPLOAD_DIRECTORY: "/app/uploads"
      APP_UPDATE_DIR: "/app/update_application"
      API_LOG_DIRECTORY: "/app/log/api_log"
      SYSTEM_LOG_DIRECTORY: "/app/log/system_log"

      # (tuỳ chọn) CORS
      # ALLOWED_ORIGINS: "http://localhost:3000,http://172.31.99.130"
    
    # Mở port để kết nối đến bên ngoài (8000:8000) theo thứ tự PORT để các thiết bị khác truy cập: PORT mở trong code và ở container
    ports:
      # - "8000:8000"
      - "${PORT_HOST}:8000"

    # === Bind mount các thư mục cần ghi/đọc ===
    volumes:
      # Thư mục lưu file upload: host ./assets/file -> container /app/uploads
      - type: bind
        source: ./assets/file  # Đường dẫn trên máy chủ
        target: /app/uploads   # Đường dẫn trong container (Phải trùng với khai báo phía trên)

      # Thư mục lưu file cập nhật phần mềm: host ./assets/update_application -> container /app/update_application
      - type: bind
        source: ./assets/update_application  # Đường dẫn trên máy chủ
        target: /app/update_application   # Đường dẫn trong container (Phải trùng với khai báo phía trên)

      # Thư mục chứa log khi gọi api
      - type: bind
        source: ./log/api_log  # Đường dẫn trên máy chủ
        target: /app/log/api_log # Đường dẫn trong container (Phải trùng với khai báo phía trên)

      # Thư mục chứa log hệ thống
      - type: bind
        source: ./log/system_log  # Đường dẫn trên máy chủ
        target: /app/log/system_log # Đường dẫn trong container (Phải trùng với khai báo phía trên)
      
    depends_on:
      - redis                                    # đảm bảo Redis sẵn sàng trước khi app khởi động

    # === Tự khởi động lại nếu crash ngoài ý muốn (Không khởi động lại do người dùng chủ động stop) ===
    restart: unless-stopped
    # Kiểm tra tình trạng của server
    # Lệnh curl ... chạy trong chính container của service, không phải trên máy host.
    # localhost nghĩa là bên trong container. Và app đang lắng nghe nội bộ cổng 8000
    # -fsS ≈ --fail --silent --show-error: nếu HTTP status >= 400 thì trả về là lỗi, tắt progress/verbose (đỡ noisy), đi kèm -s để vẫn hiện lỗi khi fail (hữu ích để debug log).
    healthcheck:
      test: ["CMD", "curl", "-fsS", "http://localhost:8000/readyz"]
      interval: 30s  # mỗi 30s kiểm tra một lần.
      timeout: 5s  # quá 5s chưa xong xem như fail.
      retries: 3  #  fail liên tiếp 3 lần → container unhealthy
      start_period: 15s  # chờ 15s sau khi container start rồi mới tính fail.
